/* ----- < 7단계 기본 수학1 > ----- */
//
//
//
//
//
/* --- < 1712 > --- */

/*
< 문제 >
	월드전자는 노트북을 제조하고 판매하는 회사이다.
	노트북 판매 대수에 상관없이 매년 임대료, 재산세, 보험료, 급여 등 A만원의 고정 비용이 들며,
	한 대의 노트북을 생산하는 데에는 재료비와 인건비 등 총 B만원의 가변 비용이 든다고 한다.

	예를 들어 A=1,000, B=70이라고 하자.
	이 경우 노트북을 한 대 생산하는 데는 총 1,070만원이 들며, 열 대 생산하는 데는 총 1,700만원이 든다.

	노트북 가격이 C만원으로 책정되었다고 한다.
	일반적으로 생산 대수를 늘려 가다 보면 어느 순간 총 수입(판매비용)이 총 비용(=고정비용+가변비용)보다 많아지게 된다.
	최초로 총 수입이 총 비용보다 많아져 이익이 발생하는 지점을 손익분기점(BREAK-EVEN POINT)이라고 한다.

	A, B, C가 주어졌을 때, 손익분기점을 구하는 프로그램을 작성하시오.

< 입력 >
	첫째 줄에 A, B, C가 빈 칸을 사이에 두고 순서대로 주어진다. A, B, C는 21억 이하의 자연수이다.

< 출력 >
	첫 번째 줄에 손익분기점 즉 최초로 이익이 발생하는 판매량을 출력한다. 손익분기점이 존재하지 않으면 -1을 출력한다.

< 풀이 >
	노트북을 제조하고 판매하는데 A의 고정 비용과 한 대의 노트북을 생상하는데 필요한 재료비, 인건비 등을 포함한 B만원의
	가변 비용이 든다. 노트북 가격을 C만원이라고 할 때 손익분기점을 구하시오.

	A(고정비용) + B(가변비용) X Z(판매량) < C(노트북 가격) X Z(판매량)
		=> A < C * Z - B * Z
		=> A < (C - B) * Z
		=> Z > A / (C - B)
			=> Z = A / (C - B) + 1
	C(노트북 가격)의 값이 B(가변비용)보다 작거나 같은 경우, 아무리 Z(판매량)값이 아무리 증가여도 이익이 생기지 않는다.
*/

//#include <iostream>
//#include <cmath>
//
//int main()
//{
//	int A, B, C;
//	std::cin >> A >> B >> C;
//
//	// 1. 만약 판매 비용이 가변 비용보다 작다면 이 회사는 절대 손익 분기점을 넘길 수 없다.
//	if (B >= C) std::cout << -1 << '\n';
//	else
//	{
//		int result = std::ceil(static_cast<double>(A) / (C - B));
//		std::cout << result << '\n';
//	}
//}

/* --- < 2292 > --- */

/*
< 문제 >
	위의 그림과 같이 육각형으로 이루어진 벌집이 있다.
	그림에서 보는 바와 같이 중앙의 방 1부터 시작해서 이웃하는 방에 돌아가면서 1씩 증가하는 번호를 주소로 매길 수 있다.
	숫자 N이 주어졌을 때, 벌집의 중앙 1에서 N번 방까지 최소 개수의 방을 지나서 갈 때 몇 개의 방을 지나가는지(시작과 끝을 포함하여)를
	계산하는 프로그램을 작성하시오. 예를 들면, 13까지는 3개, 58까지는 5개를 지난다.

< 입력 >
	첫째 줄에 N(1 ≤ N ≤ 1,000,000,000)이 주어진다.

< 출력 >
	입력으로 주어진 방까지 최소 개수의 방을 지나서 갈 때 몇 개의 방을 지나는지 출력한다.

< 풀이 >
	N번 방	|	해당하는 수	  |	  해당하는 수의 차이
	1번 방	|	1			  |
	2번 방  |	2 ~ 7		  |	  5 ( 7 - 2 )
	3번 방  |	8 ~ 19		  |	  11( 19 - 8 )
	4번 방	|   20 ~ 37		  |   17( 37 - 20 )
	5번 방	|   38 ~ 61		  |   23( 61 - 38 )

	7  -  1  = 6
	19 -  7  = 12
	37 -  19 = 18
	61 -  37 = 24

	해당하는 방의 첫 수와 마지막 수를 찾고 그 사이에 있다면 해당하는 N번 방을 출력한다.
*/

//#include <iostream>
//
//int main()
//{
//	int N;
//	std::cin >> N;
//
//	// 1. 지나가는 방의 개수는 시작 지점의 방 1부터 시작 한다.
//	int count{ 1 };
//	// 2. 벌집은 한 겹당 6의 배수로 증가하는데 시작은 1이다.
//	int range{ 1 };
//	int step{ 6 };
//
//	// 3. 입력 받은 N보다 벌집 range의 값이 더 작다면 range를 증가 시키면서 지나가는 방의 개수는 증가 시킨다.
//	while (N > range)
//	{
//		range += step;
//		step += 6;
//		count++;
//	}
//
//	std::cout << count << '\n';
//}

/* --- < 2869 > --- */

/*
< 문제 >
	땅 위에 달팽이가 있다. 이 달팽이는 높이가 V미터인 나무 막대를 올라갈 것이다.
	달팽이는 낮에 A미터 올라갈 수 있다. 하지만, 밤에 잠을 자는 동안 B미터 미끄러진다.
	또, 정상에 올라간 후에는 미끄러지지 않는다.

	달팽이가 나무 막대를 모두 올라가려면, 며칠이 걸리는지 구하는 프로그램을 작성하시오.

< 입력 >
	첫째 줄에 세 정수 A, B, V가 공백으로 구분되어서 주어진다. (1 ≤ B < A ≤ V ≤ 1,000,000,000)

< 출력 >
	첫째 줄에 달팽이가 나무 막대를 모두 올라가는데 며칠이 걸리는지 출력한다.

< 풀이 >
	달팽이가 V 길이의 막대를 낮에 A미터 올라가고 밤에는 B미터 미끄러진다는 것을 식으로 만들면 (V-A)/(A-B)가 된다.
	그리고 정상에 도달했을 때에는 미끄러지지 않으니 day는 그대로 (V-A)/(A-B)가 되고
	아니라면 (V-A)/(A-B)+1이 되어 하루를 더 지난다.
	그리고 최종적으로 1일부터 계산되어야하기 때문에 +1을 하고 출력한다.

< 풀이 >
	달팽이는 하루에( A - B )미터 씩 총 V미터를 올라가면 된다. 하지만 달팽이가 목표 지점에 도달한 날에는
	미끄러지지 않으니 총( V - B )미터를 올라가게 되는 것과 같다.
	만약( V - B )가 ( A - B )로 딱 나눠 떨어지지 않으면 몫에 + 1 한 것이 정답이다.( 하루가 더 가니까. )
	근데 int형 이기 때문에 나눠 떨어지는지 구분하기 귀찬으니까 ( V - B )에 1을 미리 빼놓고 몫에 무조건
	1을 더하는 것으로 처리한다.
*/

#include <iostream>
#include <cmath>

int main()
{
	int A, B, V;
	std::cin >> A >> B >> V;

	int days = std::ceil(static_cast<double>(V - A) / (A - B)) + 1;

	std::cout << days << '\n';
}