/* ----- < 15단계 백트래킹 > ----- */
//
//
//
//
//
/* --- < 15649 > --- */

/*
< 문제 >
	자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는
	프로그램을 작성하시오.

	#. 1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열

< 입력 >
	첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)

< 출력 >
	한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다.
	중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.

	수열은 사전 순으로 증가하는 순서로 출력해야 한다.

< 깊이 우선 탐색( DFS, Depth - First Search ) >
	< Description > : 루트 노드에서 시작해서 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법
		#1. 미로를 탐색할 때 한 방향으로 갈 수 있을 때까지 계속 가다가 더 이산 갈 수 없게 되면 가장 가까운 갈림길로 돌아와서 이곳으로 부터 다른 방향으로 다시 탐색
		#2. 즉, 넓게 탐색하기 전에 깊게 탐색하는 것
		#3. 사용하는 경우 : 모든 노드를 방문하고자 하는 경우에 사용
		#4. 깊이 우선 탐색이 너비 우선 탐색보다 좀더 간단
		#5. 단순 검색 속도 자체는 너비 우선 탐색에 비해 느림
	< 특징 >
		#1. 자기 자신을 호출하는 순환 알고리즘의 형태를 가지고 있다.
		#2. 전위 순회를 호맣나 다른 형태의 트리 순회는 모두 DFS의 한 종류이다.
		#3. 그래프 탐색의 경우 어떤 노드를 방문 했었는지 여부를 반드시 검사해야 한다.

< 풀이 >
	< 목표 > : 1부터 N까지의 자연수 중에서 중복 없이 M개의 수열을 "모두" 출력
		1) N과 M을 입력 받는다.
		2) M은 N보다 크면 않된다.
		3) N은 8보다 크면 않된다.
		4) 수열을 저장할 배열을 만든다.
		5) 백트래킹을 위한 방문 확인 배열을 만든다.
		6) for문으로 1부터 N까지 반복한다.
		7) 방문한 적 없는 수는 수열로 저장시키고 더 깊은 노드로 이동한다.
		8) 최종 목적지에서 저장된 수열을 출력한다.
		9) for문으로 돌아와서 다음 인덱스 수로 다른 수열을 저장하며 반복한다.
*/

//#include <iostream>
//
//int N, M;
//int arr[9];
//bool visited[9];
//
//void DFS(int count)	// 루트 노드 or 임의의 노드
//{
//	if (count == M)	// 루트 노드가 목표 노드에 도착할 경우
//	{	// arr[i]에 저장된 값을 M개 출력
//		for (int i = 0; i < M; i++) { std::cout << arr[i] << " "; }
//		std::cout << '\n';
//	}
//	else	// (count < M)일 경우 수열을 채운다.
//	{
//		for (int i = 1; i <= N; i++)
//		{
//			if (!visited[i])	// [i] 노드에 방문한 적이 없을 경우
//			{
//				visited[i] = true;	// 방문 표시로 바꾸고
//				arr[count] = i;		// i를 수열에 저장하고
//				DFS(count + 1);		// 다음 노드로 이동
//				visited[i] = false;	// 돌아와서 방문 하지 않음으로 다시 바꿈
//			}
//		}
//	}
//}
//
//int main()
//{
//	std::cin >> N >> M;
//	DFS(0);
//}

/* --- < 15650 > --- */

/*
< 문제 >
	자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는
	프로그램을 작성하시오.

	#. 1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열
	#. 고른 수열은 오름차순이어야 한다.

< 입력 >
	첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)
< 출력 >
	한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다.
	중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.

	수열은 사전 순으로 증가하는 순서로 출력해야 한다.

< 풀이 >
	< 목표 > : 오름차순으로 정렬된 1 ~ N까지, M개의 수열을 모두 출력
		1) N과 M을 출력 받는다.
		2) M은 N보다 크면 않된다.
		3) N은 8보다 크면 않된다.
		4) 수열을 저장할 배열을 만든다.
		5) 백트래킹을 위한 방문 확인 배열을 만든다.
		6) for문을 1부터 N까지 반복한다.
		7) 단, 재귀를 통해 깊은 노드로 들어갈 때
			=> 현재 노드의 for문 [i]인덱스보다 더 큰 값으로 다음 노드 for문을 만든다.
		8) 방문한 적 없는 수는 수열로 저장시키고 더 깊은 노드로 이동한다.
		9) 최종 목적지에서 저장된 수열을 출력한다.
		10) for문으로 돌아와서 다음 인덱스 수로 다른 수열을 저장하며 반복한다.
*/

//#include <iostream>
//
//int N, M;
//int arr[9];
//bool visited[9];
//
//void DFS(int num, int count)
//{
//	if (count == M)
//	{
//		for (int i = 0; i < M; i++) { std::cout << arr[i] << ' '; }
//		std::cout << '\n';
//	}
//	else
//	{
//		for (int i = num; i <= N; i++)
//		{
//			if (!visited[i])
//			{
//				visited[i] = true;
//				arr[count] = i;
//				DFS(i + 1, count + 1);
//				visited[i] = false;
//			}
//		}
//	}
//}
//
//int main()
//{
//	std::cin >> N >> M;
//	DFS(1, 0);
//}

/* --- < 15651 > --- */

/*
< 문제 >
	자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을
	모두 구하는 프로그램을 작성하시오.

	#. 1부터 N까지 자연수 중에서 M개를 고른 수열
	#. 같은 수를 여러 번 골라도 된다.

< 입력 >
	첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 7)

< 출력 >
	한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다.
	중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.

	수열은 사전 순으로 증가하는 순서로 출력해야 한다.

< 풀이 >
	< 목표 > : 값이 중복될 수 있는 1 ~ N까지, M개의 수열을 모두 출력
		1) N과 M을 입력 받는다.
		2) M은 N보다 크면 않된다.
		3) N은 7보다 크면 않된다.
		4) 수열을 저장할 배열을 만든다.
		5) for문으로 1부터 N까지 반복한다.
		6) 최종 목적지에서 저장된 수열을 출력한다.
		7) for문으로 돌아와서 다음 인덱스 수로 다른 수열을 저장하며 반복한다.
*/

//#include <iostream>
//
//int N, M;
//int arr[8];
//
//void DFS(int count)
//{
//	if (count == M)
//	{
//		for (int i = 0; i < M; i++) { std::cout << arr[i] << ' '; }
//		std::cout << '\n';
//	}
//	else
//	{
//		for (int i = 1; i <= N; i++)
//		{
//			arr[count] = i;
//			DFS(count + 1);
//		}
//	}
//}
//
//int main()
//{
//	std::cin >> N >> M;
//	DFS(0);
//}

/* --- < 15652 > --- */

/*
< 문제 >
	자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을
	모두 구하는 프로그램을 작성하시오.

	#. 1부터 N까지 자연수 중에서 M개를 고른 수열
	#. 같은 수를 여러 번 골라도 된다.
	#. 고른 수열은 비내림차순이어야 한다.
	#. 길이가 K인 수열 A가 A1 ≤ A2 ≤ ... ≤ AK-1 ≤ AK를 만족하면, 비내림차순이라고 한다.

< 입력 >
	첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)

< 출력 >
	한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다.
	중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.

	수열은 사전 순으로 증가하는 순서로 출력해야 한다.

< 풀이 >
	< 목표 > : 중복이 가능한 오름차순으로 정렬된 1 ~ N까지, M개의 수열을 모두 출력
		1) N과 M을 출력 받는다.
		2) M은 N보다 크면 않된다.
		3) N은 8보다 크면 않된다.
		4) 수열을 저장할 배열을 만든다.
		5) for문을 1부터 N까지 반복한다.
		6) 단, 재귀를 통해 깊은 노드로 들어갈 때
			=> 현재 노드의 for문 [i]인덱스보다 더 큰 값으로 다음 노드 for문을 만든다.
		7) 최종 목적지에서 저장된 수열을 출력한다.
		8) for문으로 돌아와서 다음 인덱스 수로 다른 수열을 저장하며 반복한다.
*/

//#include <iostream>
//
//int N, M;
//int arr[9];
//
//void DFS(int num, int count)
//{
//	if (count == M)
//	{
//		for (int i = 0; i < M; i++) { std::cout << arr[i] << ' '; }
//		std::cout << '\n';
//	}
//	else
//	{
//		for (; num <= N; num++)
//		{
//			arr[count] = num;
//			DFS(num, count + 1);
//		}
//	}
//}
//
//int main()
//{
//	std::cin >> N >> M;
//	DFS(1, 0);
//}

/* --- < 14888 > --- */

/*
< 문제 >
	N개의 수로 이루어진 수열 A1, A2, ..., AN이 주어진다.
	또, 수와 수 사이에 끼워넣을 수 있는 N-1개의 연산자가 주어진다.
	연산자는 덧셈(+), 뺄셈(-), 곱셈(×), 나눗셈(÷)으로만 이루어져 있다.

	우리는 수와 수 사이에 연산자를 하나씩 넣어서, 수식을 하나 만들 수 있다.
	이때, 주어진 수의 순서를 바꾸면 안 된다.

	예를 들어, 6개의 수로 이루어진 수열이 1, 2, 3, 4, 5, 6이고,
	주어진 연산자가 덧셈(+) 2개, 뺄셈(-) 1개, 곱셈(×) 1개, 나눗셈(÷) 1개인 경우에는
	총 60가지의 식을 만들 수 있다.
	예를 들어, 아래와 같은 식을 만들 수 있다.

	1+2+3-4×5÷6
	1÷2+3+4-5×6
	1+2÷3×4-5+6
	1÷2×3-4+5+6
	식의 계산은 연산자 우선 순위를 무시하고 앞에서부터 진행해야 한다.
	또, 나눗셈은 정수 나눗셈으로 몫만 취한다.
	음수를 양수로 나눌 때는 C++14의 기준을 따른다.
	즉, 양수로 바꾼 뒤 몫을 취하고, 그 몫을 음수로 바꾼 것과 같다.
	이에 따라서, 위의 식 4개의 결과를 계산해보면 아래와 같다.

	1+2+3-4×5÷6 = 1
	1÷2+3+4-5×6 = 12
	1+2÷3×4-5+6 = 5
	1÷2×3-4+5+6 = 7
	N개의 수와 N-1개의 연산자가 주어졌을 때,
	만들 수 있는 식의 결과가 최대인 것과 최소인 것을 구하는 프로그램을 작성하시오.

< 입력 >
	첫째 줄에 수의 개수 N(2 ≤ N ≤ 11)가 주어진다.
	둘째 줄에는 A1, A2, ..., AN이 주어진다.
	(1 ≤ Ai ≤ 100) 셋째 줄에는 합이 N-1인 4개의 정수가 주어지는데,
	차례대로 덧셈(+)의 개수, 뺄셈(-)의 개수, 곱셈(×)의 개수, 나눗셈(÷)의 개수이다.

< 출력 >
	첫째 줄에 만들 수 있는 식의 결과의 최댓값을, 둘째 줄에는 최솟값을 출력한다.
	연산자를 어떻게 끼워넣어도 항상 -10억보다 크거나 같고,
	10억보다 작거나 같은 결과가 나오는 입력만 주어진다.
	또한, 앞에서부터 계산했을 때, 중간에 계산되는 식의 결과도
	항상 -10억보다 크거나 같고, 10억보다 작거나 같다.

< 풀이 >
	먼저 수열에 입력할 수를 입력받은 후, 연산자의 개수를 입력받는다.
	필자의 경우 operators라는 크기 4짜리 배열을 선언하였고,
	덧셈, 뺼셈, 곱셈, 나눗셈의 개수를 각각 입력받았다.

	그 후, 백트래킹을 사용하여 재귀로 문제를 해결한다.

	매개변수로는 여태까지 연산의 result값, 연산을 진행할 수의 인덱스를
	입력받도록 하는 백트래킹 재귀 함수를 정의하여 풀이가 가능하다.
*/

//#include <iostream>
//
//int N;
//int operands[11];
//int operators[4];
//int myMin = 1000000001;
//int myMax = -1000000001;
//
//void GetAnswer(int result, int index)
//{
//	if (index == N)
//	{
//		if (result > myMax) { myMax = result; }
//		if (result < myMin) { myMin = result; }
//		return;
//	}
//
//	for (int i = 0; i < 4; i++)
//	{
//		if (operators[i] > 0)
//		{
//			operators[i]--;
//
//			if (i == 0) { GetAnswer(result + operands[index], index + 1); }
//			else if (i == 1) { GetAnswer(result - operands[index], index + 1); }
//			else if (i == 2) { GetAnswer(result * operands[index], index + 1); }
//			else { GetAnswer(result / operands[index], index + 1); }
//
//			operators[i]++;
//		}
//	}
//	return;
//}
//
//int main()
//{
//	std::cin >> N;
//	for (int i = 0; i < N; i++)
//	{
//		std::cin >> operands[i];
//	}
//	for (int i = 0; i < 4; i++)
//	{
//		std::cin >> operators[i];
//	}
//
//	GetAnswer(operands[0], 1);
//	std::cout << myMax << '\n' << myMin << '\n';
//}

/* --- < 9663 > --- */

/*
< 문제 >
	N-Queen 문제는 크기가 N × N인 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 문제이다.

	N이 주어졌을 때, 퀸을 놓는 방법의 수를 구하는 프로그램을 작성하시오.

< 입력 >
	첫째 줄에 N이 주어진다. (1 ≤ N < 15)

< 출력 >
	첫째 줄에 퀸 N개를 서로 공격할 수 없게 놓는 경우의 수를 출력한다.

< 풀이 >
	N-Queen 문제는 백트래킹의 가장 대표적인 예제로서,
	퀸의 특성상 체스판 한 행당 한 개의 퀸만 존재할 수 있다는 것을
	전제로 깔아두고 시작하는 것이 좋다.
	즉 이 문제를 풀기 위해서 N*N짜리 배열을 직접 만들 필요 없이,
	크기가 N인 일차원 배열을 만든 후, 각 열에 몇번째 행의 퀸이 있는지를 저장하면 된다.
	예를 들어  N = 4일때,

	일차원 배열 col [] 에 이런식으로 저장하면 된다.
	col[0] = 0번째 열에 존재하는건 1행의 퀸이므로 1 저장
	col[1] = 1번째 열에 존재하는건 3행의 퀸이므로 3 저장
	col[2] = 2번째 열에 존재하는건 0행의 퀸이므로 0 저장
	col[3] = 3번째 열에 존재하는건 2행의 퀸이므로 2 저장

	그후 한 행씩 퀸을 배치해가면서 총 배치 행수가 N이 되면
	조건을 만족하는 경우의 수를 1개씩 늘려주는 방식으로 백트래킹을 진행할 수 있다.

	따라서 재귀함수의 매개변수에는 현재 몇번째 행을 채우고 있는지를
	기록하는 Level이라는 인자를 사용해야 한다.

	먼저 이 문제에서 체크해야하는것은, 임의로 배치한 퀸이 다른 퀸과
	같은 행 또는 같은 열에 있는가를 살펴야하며, 대각선에 위치해있는가를 살펴야한다.

	이 때, 같은 행과 열에 있는지 확인하는 방법은 매우 간단하지만,
	대각선에 위치해있는지를 찾는 방식이 다소 까다로울 수 있다.
	먼저 기본적으로 대각선에 존재하는 좌표일 경우, (X, Y)의 대각선에 위치한 좌표
	(A, B)에서 반드시 X-A = Y-B를 만족한다.

	예를 들어 (0 , 1)을 기준으로 했을때,
	대각선에 있는 점들 (1, 2) (2, 3) 은 반드시 (0 - 1) = (1 - 2) = -1, (0 - 2) = (1 - 3) = -2를
	만족한다는 것이다.

	따라서 우리가 정의한 col이라는 1차원 배열의 정의에 따라서
	X좌표와 Y좌표의 차이가 일정한 값을 가질 경우 해당 퀸과 대각선에 있다고 판단할 수 있다.
*/

//#include <iostream>
//
//int EN[15];		// English : A열, B열, C열, D열... 세로 열
//int N, result;	// Number : 1행, 2행, 3행... 가로 행
//
//bool check(int NUM)
//{
//	for (int i = 0; i < NUM; i++)
//	{	// 열(인덱스) 끼리 비교하여 행(내부 원소)이 같은지 확인 ||
//		// 대각선으로 queen이 있는지 확인
//		if (EN[i] == EN[NUM] || abs(EN[NUM] - EN[i]) == NUM - i) { return false; }
//	}
//	return true;
//}
//void nqueen(int x)
//{
//	if (x == N) { result++; }
//	else
//	{	// i를 행이라고 가정하고 몇 번째 행에 queen이 들어가는지 입력해 준다.
//		for (int i = 0; i < N; i++)
//		{	// x = 0, i = 0이라고 가정하면 EN[x] = i는 0,0에 queen이 들어 같다는 의미
//			// 즉 인덱스는 열, 내부 원소는 행을 뜻한다.
//			EN[x] = i;
//			// 열에 중복되는 퀸이 없다면 다음 열로 진입, 중복되는 퀸이 있다면 for문의 i를 증가
//			if (check(x)) { nqueen(x + 1); }
//		}
//	}
//}
//int main()
//{
//	std::cin >> N;
//	nqueen(0);
//	std::cout << result;
//}