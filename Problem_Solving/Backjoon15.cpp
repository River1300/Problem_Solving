/* ----- < 15단계 백트래킹 > ----- */
//
//
//
//
//
/* --- < 15649 > --- */

/*
< 문제 >
	자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는
	프로그램을 작성하시오.

	#. 1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열

< 입력 >
	첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)

< 출력 >
	한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다.
	중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.

	수열은 사전 순으로 증가하는 순서로 출력해야 한다.

< 깊이 우선 탐색( DFS, Depth - First Search ) >
	< Description > : 루트 노드에서 시작해서 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법
		#1. 미로를 탐색할 때 한 방향으로 갈 수 있을 때까지 계속 가다가 더 이산 갈 수 없게 되면 가장 가까운 갈림길로 돌아와서 이곳으로 부터 다른 방향으로 다시 탐색
		#2. 즉, 넓게 탐색하기 전에 깊게 탐색하는 것
		#3. 사용하는 경우 : 모든 노드를 방문하고자 하는 경우에 사용
		#4. 깊이 우선 탐색이 너비 우선 탐색보다 좀더 간단
		#5. 단순 검색 속도 자체는 너비 우선 탐색에 비해 느림
	< 특징 >
		#1. 자기 자신을 호출하는 순환 알고리즘의 형태를 가지고 있다.
		#2. 전위 순회를 호맣나 다른 형태의 트리 순회는 모두 DFS의 한 종류이다.
		#3. 그래프 탐색의 경우 어떤 노드를 방문 했었는지 여부를 반드시 검사해야 한다.

< 풀이 >
	< 목표 > : 1부터 N까지의 자연수 중에서 중복 없이 M개의 수열을 "모두" 출력
		1) N과 M을 입력 받는다.
		2) M은 N보다 크면 않된다.
		3) N은 8보다 크면 않된다.
		4) 수열을 저장할 배열을 만든다.
		5) 백트래킹을 위한 방문 확인 배열을 만든다.
		6) for문으로 1부터 N까지 반복한다.
		7) 방문한 적 없는 수는 수열로 저장시키고 더 깊은 노드로 이동한다.
		8) 최종 목적지에서 저장된 수열을 출력한다.
		9) for문으로 돌아와서 다음 인덱스 수로 다른 수열을 저장하며 반복한다.
*/

//#include <iostream>
//
//int N, M;
//int arr[9];
//bool visited[9];
//
//void DFS(int count)	// 루트 노드 or 임의의 노드
//{
//	if (count == M)	// 루트 노드가 목표 노드에 도착할 경우
//	{	// arr[i]에 저장된 값을 M개 출력
//		for (int i = 0; i < M; i++) { std::cout << arr[i] << " "; }
//		std::cout << '\n';
//	}
//	else	// (count < M)일 경우 수열을 채운다.
//	{
//		for (int i = 1; i <= N; i++)
//		{
//			if (!visited[i])	// [i] 노드에 방문한 적이 없을 경우
//			{
//				visited[i] = true;	// 방문 표시로 바꾸고
//				arr[count] = i;		// i를 수열에 저장하고
//				DFS(count + 1);		// 다음 노드로 이동
//				visited[i] = false;	// 돌아와서 방문 하지 않음으로 다시 바꿈
//			}
//		}
//	}
//}
//
//int main()
//{
//	std::cin >> N >> M;
//	DFS(0);
//}

/* --- < 15650 > --- */

/*
< 문제 >
	자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는
	프로그램을 작성하시오.

	#. 1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열
	#. 고른 수열은 오름차순이어야 한다.

< 입력 >
	첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)
< 출력 >
	한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다.
	중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.

	수열은 사전 순으로 증가하는 순서로 출력해야 한다.

< 풀이 >
	< 목표 > : 오름차순으로 정렬된 1 ~ N까지, M개의 수열을 모두 출력
		1) N과 M을 출력 받는다.
		2) M은 N보다 크면 않된다.
		3) N은 8보다 크면 않된다.
		4) 수열을 저장할 배열을 만든다.
		5) 백트래킹을 위한 방문 확인 배열을 만든다.
		6) for문을 1부터 N까지 반복한다.
		7) 단, 재귀를 통해 깊은 노드로 들어갈 때
			=> 현재 노드의 for문 [i]인덱스보다 더 큰 값으로 다음 노드 for문을 만든다.
		8) 방문한 적 없는 수는 수열로 저장시키고 더 깊은 노드로 이동한다.
		9) 최종 목적지에서 저장된 수열을 출력한다.
		10) for문으로 돌아와서 다음 인덱스 수로 다른 수열을 저장하며 반복한다.
*/

//#include <iostream>
//
//int N, M;
//int arr[9];
//bool visited[9];
//
//void DFS(int num, int count)
//{
//	if (count == M)
//	{
//		for (int i = 0; i < M; i++) { std::cout << arr[i] << ' '; }
//		std::cout << '\n';
//	}
//	else
//	{
//		for (int i = num; i <= N; i++)
//		{
//			if (!visited[i])
//			{
//				visited[i] = true;
//				arr[count] = i;
//				DFS(i + 1, count + 1);
//				visited[i] = false;
//			}
//		}
//	}
//}
//
//int main()
//{
//	std::cin >> N >> M;
//	DFS(1, 0);
//}

/* --- < 15651 > --- */

/*
< 문제 >
	자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을
	모두 구하는 프로그램을 작성하시오.

	#. 1부터 N까지 자연수 중에서 M개를 고른 수열
	#. 같은 수를 여러 번 골라도 된다.

< 입력 >
	첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 7)

< 출력 >
	한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다.
	중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.

	수열은 사전 순으로 증가하는 순서로 출력해야 한다.

< 풀이 >
	< 목표 > : 값이 중복될 수 있는 1 ~ N까지, M개의 수열을 모두 출력
		1) N과 M을 입력 받는다.
		2) M은 N보다 크면 않된다.
		3) N은 7보다 크면 않된다.
		4) 수열을 저장할 배열을 만든다.
		5) for문으로 1부터 N까지 반복한다.
		6) 최종 목적지에서 저장된 수열을 출력한다.
		7) for문으로 돌아와서 다음 인덱스 수로 다른 수열을 저장하며 반복한다.
*/

//#include <iostream>
//
//int N, M;
//int arr[8];
//
//void DFS(int count)
//{
//	if (count == M)
//	{
//		for (int i = 0; i < M; i++) { std::cout << arr[i] << ' '; }
//		std::cout << '\n';
//	}
//	else
//	{
//		for (int i = 1; i <= N; i++)
//		{
//			arr[count] = i;
//			DFS(count + 1);
//		}
//	}
//}
//
//int main()
//{
//	std::cin >> N >> M;
//	DFS(0);
//}

/* --- < 15652 > --- */

/*
< 문제 >
	자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을
	모두 구하는 프로그램을 작성하시오.

	#. 1부터 N까지 자연수 중에서 M개를 고른 수열
	#. 같은 수를 여러 번 골라도 된다.
	#. 고른 수열은 비내림차순이어야 한다.
	#. 길이가 K인 수열 A가 A1 ≤ A2 ≤ ... ≤ AK-1 ≤ AK를 만족하면, 비내림차순이라고 한다.

< 입력 >
	첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)

< 출력 >
	한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다.
	중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.

	수열은 사전 순으로 증가하는 순서로 출력해야 한다.

< 풀이 >
	< 목표 > : 중복이 가능한 오름차순으로 정렬된 1 ~ N까지, M개의 수열을 모두 출력
		1) N과 M을 출력 받는다.
		2) M은 N보다 크면 않된다.
		3) N은 8보다 크면 않된다.
		4) 수열을 저장할 배열을 만든다.
		5) for문을 1부터 N까지 반복한다.
		6) 단, 재귀를 통해 깊은 노드로 들어갈 때
			=> 현재 노드의 for문 [i]인덱스보다 더 큰 값으로 다음 노드 for문을 만든다.
		7) 최종 목적지에서 저장된 수열을 출력한다.
		8) for문으로 돌아와서 다음 인덱스 수로 다른 수열을 저장하며 반복한다.
*/

//#include <iostream>
//
//int N, M;
//int arr[9];
//
//void DFS(int num, int count)
//{
//	if (count == M)
//	{
//		for (int i = 0; i < M; i++) { std::cout << arr[i] << ' '; }
//		std::cout << '\n';
//	}
//	else
//	{
//		for (; num <= N; num++)
//		{
//			arr[count] = num;
//			DFS(num, count + 1);
//		}
//	}
//}
//
//int main()
//{
//	std::cin >> N >> M;
//	DFS(1, 0);
//}

/* --- < 14888 > --- */

/*
< 문제 >
	N개의 수로 이루어진 수열 A1, A2, ..., AN이 주어진다.
	또, 수와 수 사이에 끼워넣을 수 있는 N-1개의 연산자가 주어진다.
	연산자는 덧셈(+), 뺄셈(-), 곱셈(×), 나눗셈(÷)으로만 이루어져 있다.

	우리는 수와 수 사이에 연산자를 하나씩 넣어서, 수식을 하나 만들 수 있다.
	이때, 주어진 수의 순서를 바꾸면 안 된다.

	예를 들어, 6개의 수로 이루어진 수열이 1, 2, 3, 4, 5, 6이고,
	주어진 연산자가 덧셈(+) 2개, 뺄셈(-) 1개, 곱셈(×) 1개, 나눗셈(÷) 1개인 경우에는
	총 60가지의 식을 만들 수 있다.
	예를 들어, 아래와 같은 식을 만들 수 있다.

	1+2+3-4×5÷6
	1÷2+3+4-5×6
	1+2÷3×4-5+6
	1÷2×3-4+5+6
	식의 계산은 연산자 우선 순위를 무시하고 앞에서부터 진행해야 한다.
	또, 나눗셈은 정수 나눗셈으로 몫만 취한다.
	음수를 양수로 나눌 때는 C++14의 기준을 따른다.
	즉, 양수로 바꾼 뒤 몫을 취하고, 그 몫을 음수로 바꾼 것과 같다.
	이에 따라서, 위의 식 4개의 결과를 계산해보면 아래와 같다.

	1+2+3-4×5÷6 = 1
	1÷2+3+4-5×6 = 12
	1+2÷3×4-5+6 = 5
	1÷2×3-4+5+6 = 7
	N개의 수와 N-1개의 연산자가 주어졌을 때,
	만들 수 있는 식의 결과가 최대인 것과 최소인 것을 구하는 프로그램을 작성하시오.

< 입력 >
	첫째 줄에 수의 개수 N(2 ≤ N ≤ 11)가 주어진다.
	둘째 줄에는 A1, A2, ..., AN이 주어진다.
	(1 ≤ Ai ≤ 100) 셋째 줄에는 합이 N-1인 4개의 정수가 주어지는데,
	차례대로 덧셈(+)의 개수, 뺄셈(-)의 개수, 곱셈(×)의 개수, 나눗셈(÷)의 개수이다.

< 출력 >
	첫째 줄에 만들 수 있는 식의 결과의 최댓값을, 둘째 줄에는 최솟값을 출력한다.
	연산자를 어떻게 끼워넣어도 항상 -10억보다 크거나 같고,
	10억보다 작거나 같은 결과가 나오는 입력만 주어진다.
	또한, 앞에서부터 계산했을 때, 중간에 계산되는 식의 결과도
	항상 -10억보다 크거나 같고, 10억보다 작거나 같다.

< 풀이 >
	먼저 수열에 입력할 수를 입력받은 후, 연산자의 개수를 입력받는다.
	필자의 경우 operators라는 크기 4짜리 배열을 선언하였고,
	덧셈, 뺼셈, 곱셈, 나눗셈의 개수를 각각 입력받았다.

	그 후, 백트래킹을 사용하여 재귀로 문제를 해결한다.

	매개변수로는 여태까지 연산의 result값, 연산을 진행할 수의 인덱스를
	입력받도록 하는 백트래킹 재귀 함수를 정의하여 풀이가 가능하다.
*/

//#include <iostream>
//
//int N;
//int operands[11];
//int operators[4];
//int myMin = 1000000001;
//int myMax = -1000000001;
//
//void GetAnswer(int result, int index)
//{
//	if (index == N)
//	{
//		if (result > myMax) { myMax = result; }
//		if (result < myMin) { myMin = result; }
//		return;
//	}
//
//	for (int i = 0; i < 4; i++)
//	{
//		if (operators[i] > 0)
//		{
//			operators[i]--;
//
//			if (i == 0) { GetAnswer(result + operands[index], index + 1); }
//			else if (i == 1) { GetAnswer(result - operands[index], index + 1); }
//			else if (i == 2) { GetAnswer(result * operands[index], index + 1); }
//			else { GetAnswer(result / operands[index], index + 1); }
//
//			operators[i]++;
//		}
//	}
//	return;
//}
//
//int main()
//{
//	std::cin >> N;
//	for (int i = 0; i < N; i++)
//	{
//		std::cin >> operands[i];
//	}
//	for (int i = 0; i < 4; i++)
//	{
//		std::cin >> operators[i];
//	}
//
//	GetAnswer(operands[0], 1);
//	std::cout << myMax << '\n' << myMin << '\n';
//}
