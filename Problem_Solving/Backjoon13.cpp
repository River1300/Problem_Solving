/* ----- < 13단계 기하 1 > ----- */
//
//
//
//
//
/* --- < 1085 > --- */

/*
< 문제 >
	한수는 지금 (x, y)에 있다.
	직사각형은 각 변이 좌표축에 평행하고,
	왼쪽 아래 꼭짓점은 (0, 0), 오른쪽 위 꼭짓점은 (w, h)에 있다.
	직사각형의 경계선까지 가는 거리의 최솟값을 구하는 프로그램을 작성하시오.

< 입력 >
	첫째 줄에 x, y, w, h가 주어진다.

< 출력 >
	첫째 줄에 문제의 정답을 출력한다.

< 제한 >
	1 ≤ w, h ≤ 1,000
	1 ≤ x ≤ w-1
	1 ≤ y ≤ h-1
	x, y, w, h는 정수
*/

//#include <iostream>
//#include <algorithm>
//
//int main()
//{
//	int x, y, w, h;
//	std::cin >> x >> y >> w >> h;
//
//	// 1. 더 짧은 거리를 찾아서 저장
//	int distX = std::min(x, w - x);
//	int distY = std::min(y, h - y);
//	int dist = std::min(distX, distY);
//
//	std::cout << dist << '\n';
//}

/* --- < 3009 > --- */

/*
< 문제 >
	세 점이 주어졌을 때,
	축에 평행한 직사각형을 만들기 위해서 필요한 네 번째 점을 찾는 프로그램을 작성하시오.

< 입력 >
	세 점의 좌표가 한 줄에 하나씩 주어진다.
	좌표는 1보다 크거나 같고, 1000보다 작거나 같은 정수이다.

< 출력 >
	직사각형의 네 번째 점의 좌표를 출력한다.

< ^ 연산자 >
	두 항의 같은 자리의 비트가 서로 다를 경우 1을 반환( 비트 XOR )
*/

//#include <iostream>
//
//int main()
//{
//	int x1, y1, x2, y2, x3, y3;
//	std::cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;
//
//	int x4, y4;
//
//	if (x1 == x2)
//	{
//		x4 = x3;
//	}
//	else if (x1 == x3)
//	{
//		x4 = x2;
//	}
//	else
//	{
//		x4 = x1;
//	}
//
//	if (y1 == y2)
//	{
//		y4 = y3;
//	}
//	else if (y1 == y3)
//	{
//		y4 = y2;
//	}
//	else
//	{
//		y4 = y1;
//	}
//	std::cout << x4 << ' ' << y4 << '\n';
//}

//#include <iostream>
//
//int main()
//{
//	int aX, bY, cX, dY, eX, fY;
//	std::cin >> aX >> cX >> eX >> bY >> dY >> fY;
//
//	// 직사각형의 대각선은 항상 서로를 교차한다. 
//	// 즉, 첫 번째 점과 두 번째 점을 이용하여 대각선을 찾고, 이 대각선의 끝점에 세 번째 점이 위치하게 된다. 
//	// 그렇게 되면 네 번째 점의 좌표를 찾을 수 있다.
//	// 입력으로 주어진 세 점의 좌표를 aX, bY, cX, dY, eX, fY에 저장한 후, 
//	// XOR(^) 연산을 사용하여 네 번째 점의 좌표를 계산한다.
//	// aX ^ cX ^ eX : x 좌표의 값 중에서 한 번만 나타나는 값을 찾는다. 대각선의 양 끝 중에서 x 좌표 값이 한 번만 나타나게 된다.
//	// bY ^ dY ^ fY : y 좌표의 값 중에서 한 번만 나타나는 값을 찾는다. 대각선의 양 끝 중에서 y 좌표 값이 한 번만 나타나게 된다.
//	std::cout << (aX ^ cX ^ eX) << ' ' << (bY ^ dY ^ fY) << '\n';
//}

//#include <iostream>
//
//int main() 
//{
//	int x = 0, y = 0;
//
//	// 각 점의 x좌표와 y좌표를 입력 받고, XOR 연산을 사용하여 네 점의 x좌표와 y좌표를 비교한다. 
//	// 이렇게 하면 중복되지 않는 x좌표와 y좌표가 각각 x와 y 변수에 남게 된다. 
//	// 그래서 마지막에 출력할 때 이 x와 y 값을 사용하여 직사각형의 네 번째 점의 좌표를 구한다.
//	// 여기서 XOR (^) 연산을 사용하는 이유는 XOR 연산은 두 번 등장하는 값을 취소시켜서 하나만 남기는데, 
//	// 이 문제에서는 한 번 등장하는 좌표가 직사각형의 네 번째 점의 좌표이기 때문이다.
//	for (int i = 0; i < 3; i++) 
//	{
//		int a, b;
//		std::cin >> a >> b;
//
//		x ^= a;
//		y ^= b;
//	}
//	
//	std::cout << x << ' ' << y << '\n';
//}

/* --- < 4153 > --- */

/*
< 문제 >
	과거 이집트인들은 각 변들의 길이가 3, 4, 5인 삼각형이 직각 삼각형인것을 알아냈다.
	( w = 4, h = 3, v = 5 )
	주어진 세변의 길이로 삼각형이 직각인지 아닌지 구분하시오.

< 입력 >
	입력은 여러개의 테스트케이스로 주어지며 마지막줄에는 0 0 0이 입력된다.
	각 테스트케이스는 모두 30,000보다 작은 양의 정수로 주어지며, 각 입력은 변의 길이를 의미한다.

< 출력 >
	각 입력에 대해 직각 삼각형이 맞다면 "right", 아니라면 "wrong"을 출력한다.

< 풀이 >
	직각 삼각형 = 작은 두 변들의 제곱은 가장 긴 변의 제곱과 같다.
	(3*3)+(4*4)=5*5
	9+16=25;
*/

//#include <iostream>
//#include <algorithm>
//
//int main()
//{
//	int num1, num2, num3;
//
//	while (std::cin >> num1 >> num2 >> num3)
//	{
//		if (a == 0 && b == 0 && c == 0) break;
//
//		// 1. 입력 받은 값을 정렬 하여 가잔 큰 변의 길이를 찾는다.
//		int sides[] = { num1,num2,num3 };
//		std::sort(sides, sides.size());
//		num1 = sides[0];
//		num2 = sides[1];
//		num3 = sides[2];
//		// 2. 공식에 따라 맞는지 아닌지 확인
//		if (num1* num1 + num2 * num2 = num3 * num3) std::cout << "right\n";
//		else std::cout << "wrong\n";
//	}
//}

//#include <iostream>
//
//int main()
//{
//	int x, y, z;
//
//	while (std::cin >> x >> y >> z)
//	{
//		if (x == 0 && y == 0 && z == 0) { break; }
//
//		if (x > y && x > z)
//		{
//			(y * y + z * z == x * x) ? 
//				std::cout << "right" << '\n' : std::cout << "wrong" << '\n';
//		}
//		else if (y > x && y > z)
//		{
//			(x*x+z*z==y*y)?
//				std::cout << "right" << '\n' : std::cout << "wrong" << '\n';
//		}
//		else if (z > x && z > y)
//		{
//			(x*x+y*y==z*z)?
//				std::cout << "right" << '\n' : std::cout << "wrong" << '\n';
//		}
//	}
//}

//#include<iostream>
//
//int main()
//{
//	int a, b, c;
//
//	while (std::cin>>a>>b>>c)
//	{
//		if (a == 0 && b == 0 && c == 0) { break; }
//
//		if (a * a == b * b + c * c || b * b == c * c + a * a || c * c == a * a + b * b)
//			std::cout << "right" << '\n';
//		else
//			std::cout << "wrong" << '\n';
//	}
//}

/* --- < 2477 > --- */

/*
< 문제 >
	시골에 있는 태양이의 삼촌 댁에는 커다란 참외밭이 있다.
	문득 태양이는 이 밭에서 자라는 참외가 도대체 몇 개나 되는지 궁금해졌다.
	어떻게 알아낼 수 있는지 골똘히 생각하다가 드디어 좋은 아이디어가 떠올랐다.
	유레카! 1m2의 넓이에 자라는 참외 개수를 헤아린 다음,
	참외밭의 넓이를 구하면 비례식을 이용하여 참외의 총개수를 구할 수 있다.

	1m2의 넓이에 자라는 참외의 개수는 헤아렸고, 이제 참외밭의 넓이만 구하면 된다.
	참외밭은 ㄱ-자 모양이거나 ㄱ-자를 90도, 180도, 270도 회전한 모양(┏, ┗, ┛ 모양)의 육각형이다.
	다행히도 밭의 경계(육각형의 변)는 모두 동서 방향이거나 남북 방향이었다.
	밭의 한 모퉁이에서 출발하여 밭의 둘레를 돌면서 밭경계 길이를 모두 측정하였다.

	예를 들어 참외밭이 위 그림과 같은 모양이라고 하자.
	그림에서 오른쪽은 동쪽, 왼쪽은 서쪽, 아래쪽은 남쪽, 위쪽은 북쪽이다.
	이 그림의 왼쪽위 꼭짓점에서 출발하여, 반시계방향으로 남쪽으로 30m, 동쪽으로 60m,
	남쪽으로 20m, 동쪽으로 100m, 북쪽으로 50m,
	서쪽으로 160m 이동하면 다시 출발점으로 되돌아가게 된다.

	위 그림의 참외밭  면적은 6800m2이다.
	만약 1m2의 넓이에 자라는 참외의 개수가 7이라면,
	이 밭에서 자라는 참외의 개수는 47600으로 계산된다.

	1m2의 넓이에 자라는 참외의 개수와,
	참외밭을 이루는 육각형의 임의의 한 꼭짓점에서 출발하여 반시계방향으로
	둘레를 돌면서 지나는 변의 방향과 길이가 순서대로 주어진다.
	이 참외밭에서 자라는 참외의 수를 구하는 프로그램을 작성하시오.

< 입력 >
	첫 번째 줄에 1m2의 넓이에 자라는 참외의 개수를 나타내는 양의 정수 K (1 ≤ K ≤ 20)가 주어진다.
	참외밭을 나타내는 육각형의 임의의 한 꼭짓점에서 출발하여 반시계방향으로
	둘레를 돌면서 지나는 변의 방향과 길이 (1 이상 500 이하의 정수) 가
	둘째 줄부터 일곱 번째 줄까지 한 줄에 하나씩 순서대로 주어진다.
	변의 방향에서 동쪽은 1, 서쪽은 2, 남쪽은 3, 북쪽은 4로 나타낸다.

< 출력 >
	첫째 줄에 입력으로 주어진 밭에서 자라는 참외의 수를 출력한다.

< 풀이 >
	큰 사각형에서 작은 사각형을 빼면 되는 문제
	다만, 작은 사각형을 어떻게 구할 것이냐?

	조건에 따라 무조건 반시계 방향으로 정보가 주어지기 때문에 반드시
	첫 번째 잘리지 않은 변과 두 번째 잘리지 않은 변은 index가 1차이, 즉 붙어 있을 것이다.

	따라서 두 번째 잘리지 않은 변을 찾는 다면 그에 따라 index+2와 indxe+3인 변의 정보를 쓰면 된다.
*/

//#include <iostream>
//
//int main()
//{
//	std::pair<int, int> block[6];
//
//	int count;
//	std::cin >> count;
//
//	int high{}, width{};
//	int temp1, temp2;
//
//	for (int i = 0; i < 6; i++)
//	{
//		// 1. 지나가는 변의 방향 + 변의 길이를 입력 받는다.
//		std::cin >> block[i].first >> block[i].second;
//
//		// 2. 변의 방향이 수평( Horizontal )이고 그 변의 길이가 길다면
//		if ((block[i].first == 1 || block[i].first == 2) && width < block[i].second)
//		{
//			// 3. 변의 길이를 저장하고 시작 지점에서 몇 번째로 그려진 변인지 인덱스를 저장한다.
//			width = block[i].second;
//			temp1 = i;
//		}
//		// 4. 변의 방향이 수직( Vertical )이고 그 변의 길이가 길다면
//		if ((block[i].first == 3 || block[i].first == 4) && high < block[i].second)
//		{
//			// 5. 변의 길이를 저장하고 시작 지점에서 몇 번째로 그려진 변인지 인덱스를 저장한다.
//			high = block[i].second;
//			temp2 = i;
//		}
//	}
//
//	int index;
//
//	// 6. 수평으로 가장 긴 변의 다음에 그려진 변 == 수직으로 가장 긴 변
//	//		=> 작은 사각형의 시작 변의 인덱스를 찾기 위한 작업
//	if (block[(temp1 + 1) % 6].second == block[temp2].second)
//	{
//		index = temp2;
//	}
//	else
//	{
//		index = temp1;
//	}
//
//	int mh{ block[(index + 2) % 6].second };
//	int mw{ block[(index + 3) % 6].second };
//
//	// 7. 큰 사각형과 작은 사각형을 뺀다.
//	int big{ high * width };
//	int smol{ mh * mw };
//
//	std::cout << (big - smol) * count << '\n';
//}

//#include <iostream>
//
//int main() 
//{
//	int count;
//	std::cin >> count;
//
//	int way[6], value[6];
//	for (int i = 0; i < 6; i++) 
//	{
//		// 1. 일단 각 변을 입력 받는다.
//		std::cin >> way[i] >> value[i];
//	}
//
//	int temp, index;
//	int max{ -1 };
//	for (int i = 0; i < 6; i++) 
//	{
//		// 2. 넓이 가장 큰 조합을 찾아 낸다.
//		temp = value[i] * value[(i + 1) % 6];
//		if (max < temp) 
//		{
//			max = temp;
//			// 3. 가장 큰 변( 수평과 수직 )은 서로 붙어 있는데 그 중 먼저 그려진 변의 인덱스를 저장한다.
//			index = i;
//		}
//	}
//
//	// 4. 먼저 그려진 큰 변의 인덱스, 그 다음, 그 다음, 그 다음에 그려진 변이 작은 사각형의 시작 변이 된다.
//	int min = value[(index + 3) % 6] * value[(index + 4) % 6];
//	std::cout << (max - min) * count << '\n';
//}

/* --- < 3053 > --- */

/*
< 문제 >
	19세기 독일 수학자 헤르만 민코프스키는 비유클리드 기하학 중 택시 기하학을 고안했다.
	택시 기하학에서 두 점 T1(x1,y1), T2(x2,y2) 사이의 거리는 다음과 같이 구할 수 있다.

	D(T1,T2) = |x1-x2| + |y1-y2|

	두 점 사이의 거리를 제외한 나머지 정의는 유클리드 기하학에서의 정의와 같다.
	따라서 택시 기하학에서 원의 정의는 유클리드 기하학에서 원의 정의와 같다.

	원: 평면 상의 어떤 점에서 거리가 일정한 점들의 집합
	반지름 R이 주어졌을 때, 유클리드 기하학에서 원의 넓이와,
	택시 기하학에서 원의 넓이를 구하는 프로그램을 작성하시오.

< 입력 >
	첫째 줄에 반지름 R이 주어진다. R은 10,000보다 작거나 같은 자연수이다.

< 출력 >
	첫째 줄에는 유클리드 기하학에서 반지름이 R인 원의 넓이를,
	둘째 줄에는 택시 기하학에서 반지름이 R인 원의 넓이를 출력한다.
	정답과의 오차는 0.0001까지 허용한다.

< 풀이 >
	반지름 * 반지름 * 3.14
	반지름 * 반지름 * 2

	유클리드 기하학에서 두 지점의 거리는 좌표평면 상 최단거리를 말한다.
	하지만 실제 도시에서 택시가 한 지점에서 다른 지점으로 이동한다고 생각해보자.
	택시는 건물을 뚫고 지나갈 수 없으므로 건물을 피해 좌우로 꺾어 이동할 것이다.
*/

//#include <iostream>
//
//int main()
//{
//	double R;
//	std::cin >> R;
//
//	std::cout.precision(6);
//	std::cout << R * R * 3.1415926535 << '\n';
//	std::cout << R * R * 2 << '\n';
//}

//#include <iostream>
//
//int main()
//{
//	int R;
//	std::cin >> R;
//
//	double U{ static_cast<double>(R) * R * 3.14159265359 };
//	double T{ static_cast<double>(R) * R * 2 };
//
//	std::cout.precision(6);
//	std::cout.setf(std::ios::fixed, std::ios::floatfield);
//	std::cout << U << '\n' << T << '\n';
//}